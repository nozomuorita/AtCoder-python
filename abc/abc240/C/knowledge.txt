以下のようなdp配列を定義

dp = [[0]*(x+1) for _ in range(n+1)]

dp[i][j]は、i 回目のジャンプをして、位置j にたどり着くことができるかを表す(0: 不可能、1: 可能)
最初は、0回ジャンプをして、位置0にいるので、dp[0][0] = 1と初期化

入力例１の場合、最初のdp配列は以下のようになる。

dp = [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

このdp配列の各要素をfor文で回していき、以下に従って更新する。
dp[i][j]が１ならば、dp[i+1][j+a] と dp[i+1][j+b]を１にする(ただしｘを超えない場合、戻ることはできないためｘを超えたものは考える必要ない)

ex)
１．dp[0][0] = 1である(i=0, j=0)
２．すなわち、0回ジャンプをして、位置0にいることができる
３．１回目のジャンプを行い、j+a と j+bに移動することが可能
４．１回目のジャンプはab[0][0]とab[0][1]であるので、dp[i+1][j+ab[i][0]] と dp[i+1][j+ab[i][1]]を１とする
５．これを、n回目のジャンプについて考慮するまで(for i in range(n))繰り返す
６．ｎ回ジャンプした後、ｘに到達可能であるかは、dp[n][x] (=dp[-1][-1])にあるのでそれを出力

１回目のジャンプ後、２回目のジャンプ後のdp配列は以下のようになる

１回目のジャンプ後(3と6に到達可能)
dp = [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]

２回目のジャンプ後(7と8と10に到達可能)
dp = [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1]]