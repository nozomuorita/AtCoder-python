"""
答えになりうるのは、A_i か (B_i)+1である

以下、手順(具体例はサンプル１のもの)
１．売り手情報A、買い手情報Bをソートする(二分探索するため)
２．A_i と (B_i)+1 をまとめたリストcを作成し、重複を消してソート(重複があると同じ値を調べることになるため)
３．c の各値について条件を満たすか判定(for i in c)
４．i 円で売りたいと考える人は、ソートした a について bisect_right としたときの値(インデックス)
    ex) a が以下の場合を考える

        a = [90 110 120]
        　　　　
        このとき
        i = 81 なら、bisect_rightは、0
        i = 90 なら、bisect_rightは、1
        i = 110 なら、bisect_rightは、2

        となり得られる値は、i 以下の要素数となるため、ほしい値を得ることができる(i を挿入したときに左側にくる値の数)。
        ※bisect_rightとしないと、i が a に含まれる場合に、間違った値をとってしまう(a にといて i 以下の値のものが売りたい人なのでそれらが左側に来るように挿入)

５．i 円で買いたいと考える人は、ソートした b について bisect_left としたときの値(インデックス)を m (買い手の総人数)から引いたもの
    ex) b が以下のものを考える

        b = [80 100 120 10000]

        このとき
        i = 81 なら、bisect_left は１で、m - 1 = 4 - 1 = 3
        i = 90 なら、bisect_left は１で、m - 1 = 4 - 1 = 3
        i = 110 なら、bisect_leftは２で、m - 2 = 4 - 2 = 2

        となり得られるのは、i 以上の要素数となるため、ほしい値を得ることができる(i を挿入したときに右側にくる値の数)。
        ※bisect_leftとすることで、挿入する値以上のものは右側に来る → 右側に来る人たちが買いたい人
        ※挿入した場所より右側にいる人の人数は、リストの長さ(今は、買い手の総数)から得た値(インデックス)を引いたもので得られる

６．４と５で得られた値(i 円で売りたい人数と i 円で買いたい人数)を比較し、条件(売りたい人数 >= 買いたい人数)を満たすならその値段が答えとなる
    ※cはソートしているため、小さい値段から見ていっている → 条件を満たした時点でそれが最小値！
"""

from bisect import bisect_left, bisect_right
n, m = map(int, input().split())
a = list(map(int, input().split()))
b = list(map(int, input().split()))

# 二分探索をするためソートする必要がある
a.sort()
b.sort()

# ansとなりうるのは、A_i か (B_i)+1 である
# そのためそれらの値をまとめたリストを作る
c = a.copy()
for i in b:
    c.append(i+1)
c = list(set(c)) # 一度set型にして重複をなくす
c.sort()

# 答えになりうる値について一つずつ確認
for i in c:
    # i円で売りたい人数は、右側挿入時のインデックス
    num_n = bisect_right(a, i)
    # i円で買いたい人は、左側挿入時インデックスをmから引いたもの
    num_m = m - bisect_left(b, i)
    
    # 売りたい人数のほうが大きいなら答え
    if num_n >= num_m:
        ans = i
        break

print(ans)