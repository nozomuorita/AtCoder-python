"""
皿に足していくアメの個数A[i]におけるX mod Nは0~N-1の間の値をとる。
X mod N(Aの添え字)について、一度出てきたものが再び出てきたとき、その後は周期的になっているといえる。

ex: サンプルケース1の場合、3回目以降も考えると、足していくアメは
    A[0] → A[2] → A[3] → A[1] → A[2] → A[3] ...
    となる。すなわち、2,3,1,2,3,1...と2以降は周期的になっている。
    
ゆえに、k回の操作を行っていき、X mod Nについて、一度出てきたものが、再び出てくるまで調べる。
再び出てきた添え字があれば、一度目に出てきたところを始点として周期的である。
なのであとは、残りの操作回数のなかで、その周期を用いて足していく操作をすることで求まる。
※X mod Nは0~N-1であり、Nは10**5程度なので、周期を調べることは計算量的にも問題ない
"""

n, k = map(int, input().split())
a = list(map(int, input().split()))

# 周期を求める
ans = 0
l = []                  #  各操作での添え字を入れていく
f = [False] * n         #  f[i]: 添え字iが出現したかどうか
for i in range(k):
    # 添え字idxを求める
    idx = ans % n
    # もし、添え字idxがすでに出現しているなら、周期がわかったのでループを抜ける
    if f[idx]:
        break
    # まだ出現していないなら、lにidxを追加し、fをTrueとする
    # また、ansにアメの個数を追加
    l.append(idx)
    ans += a[idx]
    f[idx] = True
    
# t: 残り操作回数
t = k - len(l)

# 周期の始点を調べる
# l[i]がidxであれば、そこが始点
for i in range(len(l)):
    if l[i] == idx:
        break

# l2: 周期部分のリストにする(要素はAの添え字)
# l3: 周期部分のアメの個数をリストにする(要素は追加するアメの個数)
l2 = l[i:]
l3 = [a[j] for j in l2]
# 周期部分の追加するアメの個数の総和
s = sum(l3)

# ansに可能な周期分のアメの個数を足す
# ”残りの操作回数”を”1周期分の長さ”で割ったときの商＝足すことのできる周期の回数
ans += (t // (len(l2))) * s

# tから、足した文の操作回数分だけ引く
t -= (t // len(l2)) * len(l2)

# 残ったt(1周期分はなかったもの＝あまり)は順に足していく
for j in range(t):
    ans += l3[j]
    
print(ans)