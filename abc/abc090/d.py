"""
・bを固定して考える
・b=1のときはa/bの余りがすべて0になるため、k=0ならans+=nとする(例外処理)
・b>=2について
・a<=(b-1)についてはa自身が余りとなる
・すなわち、1, 2, 3,...,(b-2), (b-1)の中で、k以上のものの数がansにプラスされる(14~16行目)
・残りはb~nまでの数について、0, 1, 2,..., (b-1)が連続している
・(n-b+1)をbで割った商だけ0, 1, 2,...,(b-1)の塊がある
・0, 1, 2,...,(b-1)の中でk以上のものの個数*商だけansに足す
・(n-b+1)をbで割った余りの個数だけ0, 1, 2...(b-1)が残っている(余り=1なら0が1個ある、余り=2なら0,1が残っている)
・0, 1,...,(r-1)の中でk以上のものの個数を足す
・以上で答え
"""
n, k = map(int, input().split())
ans = 0

# b固定
if k==0: ans+=n               # b=1だけ例外処理
for b in range(2, n+1):
    if k<=max(b-1, 1):
        score = max(b-1, 1)-max(k, 1)+1
        ans += score
    
    if k<=(b-1):
        base = b-1-k+1
    else:
        base = 0
    
    ans += ((n-b+1)//b) * base
    r = (n-b+1) % b
    if k<=(r-1):
        ans += (r-1)-k+1

print(ans)