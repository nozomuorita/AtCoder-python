"""
前後半が入れ替わるのかどうかをTrue, Falseで管理する

※クエリ２は１回起きるごとに(前後半入れ替え)→(前後半入れ替え)となるため、偶数回起きた時は変化なしとなる
ex)２回起きると元に戻る
F L I P
   ↓　(クエリ２)
I P F L
   ↓　(クエリ２)
F L I P

よって、クエリ２は前後半が入れ替わるかどうかを管理するフラグを反転させるだけで十分
クエリ１については、クエリ２による前後半を入れ替えるかどうかのフラグにより処理が異なる。

前後半を入れ替えない(フラグがFalse)のとき
→そのままスワップ
前後半を入れ替える(フラグがTrue)のとき
→以下の操作を行う
１．x(aまたはb)において、x<=(n-1)の場合、
    x += n
２．x>(n-1)の場合、
    x -= n

具体例を以下に示す。
  入れ替えていないとき          入れ替えたとき
        0 1 2 3                  0 1 2 3
        F L I P                  F L I P
           ↓                        ↓
        0 1 2 3                  0 1 2 3
        F L I P                  I P F L

入れ替えない場合 → インデックスがそのまま
入れ替えた場合 → インデックスが半分以上のとき(n以上のとき)はnだけ引く、半分以下のときはnを足すことでインデックスを対応付けることができる。

したがって、これらの操作をすることで計算量を減らして処理できる。
最後の出力時もフラグがTrueなら、前後半を入れ替えて出力
"""

n = int(input())
s = list(input())
q = int(input())
rev = False

for _ in range(q):
    t, a, b = map(int, input().split())
    a, b = a-1, b-1
    
    if t==1:
        if rev:
            if a<n: a+=n
            else: a-=n
            if b<n: b+=n
            else: b-=n

        s[a], s[b] = s[b], s[a]

    else:
        rev = not(rev)

if rev:
    ans = "".join(s[n:]) + "".join(s[:n])
else:
    ans = "".join(s)
    
print(ans)